<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- Custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹폰트 추가 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="IT기반기술교육 블로그" />
    <link rel="shortcut icon" href="https://jang-seonguk.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://jang-seonguk.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="IT Technical Training" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="IT기반기술교육 블로그" />
    <meta property="og:url" content="https://jang-seonguk.github.io/search" />
    <meta property="og:image" content="https://jang-seonguk.github.io/assets/built/images/sky.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="IT기반기술교육 블로그" />
    <meta name="twitter:url" content="https://jang-seonguk.github.io/" />
    <meta name="twitter:image" content="https://jang-seonguk.github.io/assets/built/images/sky.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="IT Technical Training" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "IT Technical Training",
        "logo": "https://jang-seonguk.github.io/"
    },
    "url": "https://jang-seonguk.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://jang-seonguk.github.io/assets/built/images/sky.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://jang-seonguk.github.io/search"
    },
    "description": "IT기반기술교육 블로그"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://jang-seonguk.github.io/">IT Technical Training</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-data_structure" role="menuitem"><a href="/tag/datastructure/">Data Structure</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "searhcingsorting": {
        "title": "Data_Structure - Searching &amp; Sorting",
            "author": "jang-seonguk",
            "category": "",
            "content": "      정렬과 탐색(Searching &amp; Sorting)  4.1 정렬이란?정렬(sorting)은 데이터를 순서대로 재배열하는 것을 말한다. 정렬되어 있지 않은 자료에 대해서는 탐색의 효율이 크게 떨어지므로 정렬은 필수적이다.정렬시켜야 될 대상을 보통 레코드(record)라고 부른다. 또한 레코드는 여러 개의 필드(field)로 이루어진다. 정렬의 기준이 되는 필드를 키(key) 또는정렬 키(sort key)라고 한다. 결국 정렬이란 레코드들을 키(key)의 순서로 재배열하는 것이다.####정렬 장소에 따른 분류      내부(internal) 정렬 : 모든 데이터가 메인 메모리에 올라와 있는 정렬을 의미한다.        외부(external) 정렬 : 외부 기억 장치에 대부분의 데이터가 있고 일부만 메모리에 올려 정렬하는 방법으로 대용량 자료를 정렬하기 위해 사용한다.  ####구현 복잡도와 알고리즘 효율성에 따른 분류      단순하지만 비효율적인 방법 : 삽입정렬, 선택정렬, 버블정렬 등        복잡하지만 효율적인 방법 : 퀵 정렬, 힙 정렬, 병합정렬, 기수정렬 등  ####안정성에 따른 분류안전성(stability)이란 입력 데이터에 동일한 킷값을 갖는 레코드가 여러 개 존재할 경우, 정렬 후에도 이들의 상대적인 위치가 바뀌지 않는 것을 말한다.안전성을 충족하는 정렬에는 삽입정렬, 버블정렬, 병합정렬 등이 있다.4.2 간단한 정렬 알고리즘####선택 정렬(selection sort) 알고리즘def printStep(arr, val):    print(\" Step %2d = \" % val, end='')    print(arr)def selection_sort(A):    n = len(A)    for i in range(n-1):        least = i;        for j in range(i+1, n):            if (A[j] &lt; A[least]):                least = j        A[i], A[least] = A[least], A[i]        printStep(A, i+1)선택 정렬은 입력 배열 이외에 추가적인 배열을 사용하지 않는다. 이러한 정렬 방법을 제자리 정렬(in-place sorting)이라 한다.선택 정렬은 시간 복잡도가 O(n²)이다.####삽입 정렬(insertion sort) 알고리즘def printStep(arr, val):    print(\" Step %2d = \" % val, end='')    print(arr)def insertion_sort(A):    n = len(A)    for i in range(1,n):        key = A[i]        j = i-1        while j &gt;= 0 and A[j] &gt; key:            A[j+1] = A[j]            j -= 1        A[j+1] = key        printStep(A, i)삽입 정렬은 시간 복잡도가 O(n²)인데, 특히 많은 레코드들의 이동을 포함하므로 레코드의 크기가 크고 양이 많은 경우 효율적이지 않다.반면에 알고리즘이 간단하므로 레코드의 수가 적을 경우 효과적이다. 특히 대부분의 레코드가 이미 정렬되어 있는 경우 효율적으로 사용될 수 있다.####버블 정렬(bubble sort) 알고리즘def printStep(arr, val):    print(\" Step %2d = \" % val, end='')    print(arr)def bubble_sort(A):    n = len(A)    for i in range(n-1, 0, -1):        bChanged = False        for j in range(i):            if (A[j] &gt; A[j+1]):                A[j], A[j+1] = A[j+1], A[j]                bChanged = True        if not bChanged:            break;        printStep(A, n-i)버블 정렬의 시간 복잡도는 O(n²)이다. 만약 입력 자료가 역순으로 정렬되어 있는 경우에는 오랜 시간이 걸리고, 이미 정렬 되어 있는경우에는 한 번의 스캔 만에 알고리즘이 종료된다. 버블 정렬은 매우 단순하지만 효율적이지는 않다. 따라서 입력 데이터가 어느 정도 정렬되어있는 경우에 효과적으로 사용될 수 있다.4.3 정렬 응용 : 집합####삽입 연산 알고리즘def insert(self, elem):    if elem in self.items:        return    for idx in range(len(self.items)):        if elem &lt; self.items[idx]:            self.items.insert(idx, elem)            return    self.items.append(elem)####비교 연산 알고리즘def __eq__(self, setB):    if self.size() != setB.size():        return False    for idx in range(len(self.items)):        if self.items[idx] != setB.items[idx]:            return False    return True####합 연산 알고리즘def union(self, setB):    newSet = Set()    a = 0    b = 0    while a &lt; len(self.items) and b &lt; len(setB.items):        valueA = self.items[a]        valueB = self.items[b]        if valueA &lt; valueB:            newSet.items.append(valueA)            a += 1        elif valueA &gt; valueB:            newSet.items.append(valueB)            b += 1        else:            newSet.items.append(valueA)            a += 1            b += 1    while a &lt; len(self.items):        newSet.items.append(self.items[a])        a += 1    while b &lt; len(setB.items):        newSet.items.append(setB.items[b])        b += 1    return newSet정렬을 사용하면 삽입이 약간 번거롭기는 하지만 집합의 여러 연산들을 훨씬 효율적으로 처리할 수 있다.4.4 간단한 탐색 알고리즘탐색은 레코드(record)의 집합에서 원하는 레코드를 찾는 작업이다. 보통 이러한 레코드들의 집합을 테이블(table)이라고 부른다. 레코드들은 서로를 구별하여 인식할 수 있는 키(key)를 가지고 있는데, 이것을 탐색키(search key)라고 한다. 결국 탐색은 테이블에서 원하는 탐색키를 가진 레코드를 찾는 작업이다.####순차 탐색(sequential search) 알고리즘def sequential_search(A, key, low, high):    for i in range(low, high+1):        if A[i].key == key:            return i    return None####이진 탐색(binary search) 알고리즘def binary_search(A, key, low, high):    if (low &lt;= high):        middle = (low+high) // 2        if key == A[middle].key:            return middle        elif (key &lt; A[middle].key):            return binary_search(A, key, low, middle-1)        else:            return binary_search(A, key, middle + 1, high)    return None####이진 탐색 반복 구조 알고리즘def binary_search_iter(A, key, low, high):    while(low &lt;= high):        middle = (low + high) // 2        if key == A[middle].key:            return middle        elif (key &gt; A[middle].key):            low = middle + 1        else:            high = middle - 1    return None####보간 탐색 (interpolation search)def binary_search(A, key, low, high):    if (low &lt;= high):        middle = int(low + (high-low) * (key-A[low].key) / (A[high].key - A[low].key))        if key == A[middle].key:            return middle        elif (key &lt; A[middle].key):            return binary_search(A, key, low, middle-1)        else:            return binary_search(A, key, middle + 1, high)    return None4.5 고급 탐색 구조 : 해싱해싱은 킷값에 산술적인 연산을 적용하여 레코드가 저장되어야 할 위치를 직접 계산하는 방법이다. 따라서 탐색은 테이블에 있는 레코드를 하나씩 비교하는 것이 아니라탐색키로부터 레코드가 있어야 할 위치를 계산하고, 그 위치에 레코드가 있는지를 확인만 하면 된다. 해싱에서 킷값으로부터 레코드가 저장될 위치를 계산하는 함수를해시 함수(hash function)라 한다. 또한 해시 함수에 의해 계산된 위치에 레코드를 저장한 테이블을 해시 테이블(hash table)이라 한다.해싱과 오버플로해시 테이블은 M개의 버킷(bucket)으로 이루어지는 테이블이고, 하나의 버킷은 여러 개의 슬롯(slot)을 가지는데, 하나의 슬롯에는 하나의 레코드가 저장된다.킷값 key가 입력되면 해시 함수로 연산한 결과 h(key)가 해시 주소가 되고, 이를 인덱스로 사용하여 항목에 접근한다. 그런데 버킷이 충분하지 않으면 경우에 따라 서로 다른키가 해시함수에 의해 같은 주소로 계산되는 상황이 발생한다. 이것을 충돌(collision)이라고 하고, 충돌을 일으키는 키들을 동의어(synonym)라 한다.오버플로(overflow)란 충돌이 슬롯 수보다 더 많이 발생하는 경우를 의미한다.####선형 조사에 의한 오버플로 처리선형 조사법(linear probing)은 해싱 함수로 계산된 버킷에 빈 슬롯이 없으면 그 다음 버킷에서 빈 슬롯이 있는지를 찾는 방법이다. 이때 비어 있는 공간을 찾는 것을 조사(probing)라고 한다. 선형 조사법은 해시 테이블의 k번째 위치인 ht[k]에서 충돌이 발생했다면 다음 위치인 ht[k+1]부터 순서대로 비어 있는지를 살피고(조사), 빈 공간이 있으면 저장한다.이 과정은 비어있는 공간이 나올 때까지 계속된다. 만약 테이블의 끝에 도달하면 다시 테이블의 처음으로 간다. 만약 조사 과정에서 처음 충돌이 발생한 곳으로 다시 돌아왔다면 테이블이가득 찬 상태이다.선형 조사법으로 삽입 연산을 진행하다 보면 군집화(clustering)현상이 발생하게 되는데, 군집화(clustering)란 충돌이 발생한 위치에서 항목들이 집중되는 현상을 의미한다.선형 조사법은 간단하지만 오버플로가 자주 발생하면 군집화 현상에 따라 탐색의 효율이 크게 저하될 수 있다.####이차 조사법(quadratic probing)군집화 문제를 완하시키기 위한 방법으로 충돌이 발생하면 다음에 조사할 위치를 다음 식에 의해 결정하는 방법이다  (h(k) + i*i) % M  for i = 0,1,…….,M-1따라서 조사되는 위치는 h(k), h(k)+1, h(k)+4, h(k)+9와 같이 움직인다. 물론 계산된 주소에 나머지 연산(%M)을 적용해야 한다. 이 방법은 군집화 현상을 완화시킬 수 있는데,물론 2차 집중 문제를 일으킬 수는 있지만 1차 집중처럼 심각한 것은 아니다. 2차 집중의 이유는 동일한 위치로 사상되는 여러 탐색키들이 같은 순서에 의하여 빈 버킷을 조사하기 때문이다.####이중 해시법(double hashing) 재해싱(rehashing)이라고도 불리는 이 방법은 충돌이 발생해 저장할 다음 위치를 결정할 때, 원래 해시 함수와 다른 별개의 해시 함수를 이용하는 방법이다. 선형 조사법과 이차 조사법은 충돌이 발생하면 해시 함수 값에 각각 1 또는 j²를 더해서 다음 위치를 얻는다.따라서 해시 함수 값이 같으면 다음 위치도 같게 된다. 이중 해시법은 해시 함수 값이 같더라도 탐색키가 다르면 서로 다른 조사 순서를 갖도록 하여 2차 집중을 완화할 수 있다.####체이닝(chaining)에 의한 오버플로 처리체이닝은 하나의 버킷에 여러 개의 레코드를 저장할 수 있도록 하는 방법으로, 버킷은 보통 연결 리스트로 구현한다. 체이닝을 이용해 크기가 7인 해시 테이블에 h(k) = k % 7의 해시 함수를 이용하여 8, 1, 9, 6, 13을 삽입하는 과정을 보면,  8 저장: h(8) = 8 % 7 = 1 =&gt; 저장  1 저장: h(1) = 1 % 7 = 1 =&gt; 충돌 =&gt; 새로운 노드 생성 및 저장  9 저장: h(9) = 9 % 7 = 2 =&gt; 저장  6 저장: h(6) = 6 % 7 = 6 =&gt; 저장  13 저장: h(13) = 13 % 7 = 6 =&gt; 충돌 =&gt; 새로운 노드 생성 및 저장체이닝에서 항목을 탐색하거나 삽입하고자 하면 킷값의 버킷에 해당하는 연결 리스트에서 독립적으로 탐색이나 삽입이 이루어진다. 체이닝은 해시 테이블을 연결 리스트로구성하므로 필요한 만큼의 메모리만 사용하게 되어 공간적 사용 효율이 매우 우수하다. 또한 오버플로가 발생할 경우에도 해당 버킷에 할당된 연결 리스트만 처리하게 되므로수행 시간 면에서도 효율적이다.####제산 함수테이블의 크기가 M일 때 탐색키 k에 대하여 해시함수는 다음과 같다.  h(k) = k mod M이때, 가능하면 해시 테이블의 크기 M은 소수(prime number)를 선택한다. 즉, 1과 자기 자신만을 약수로 가지는 수라면 k % M이 0에서 M-1을 골고루 사용하는 값을 만들어낼 수 있기때문이다.####폴딩 함수탐색키가 해시 테이블의 크기보다 더 큰 정수일 경우에 사용된다. 예를 들어 탐색키가 32비트이고 해시 테이블의 인덱스가 16비트라고 생각해 보자. 만약 탐색키의 일부만을(예를 들어 뒤쪽 16비트)사용한다면 많은 충돌이 발생할 수 있다. 보다 좋은 방법은 탐색키를 몇 개의 부분으로 나누어 이를 더하거나 비트별 XOR와 같은 부울 연산을 이용하는 것인데, 이를 폴딩(folding)이라고 한다.폴딩 함수에서 탐색키를 나누고 더하는 방법에는 이동 폴딩(shift folding)과 경계 폴딩(boundary folding)이 대표적이다.이동 폴딩은 탐색키를 여러 부분으로 나눈 값들을 더하고, 경계 폴딩은 이웃한 부분을 거꾸로 더해 해시 주소를 얻는다.####중간 제곱 함수탐색키를 제곱한 다음, 중간의 몇 비트를",
        "url": "/SearhcingSorting"
    }
    ,
    
    "linkedlist": {
        "title": "Data_Structure - Queue",
            "author": "jang-seonguk",
            "category": "",
            "content": "      연결 리스트(Linked List)  3.1 연결 리스트(Linked List)란?항목들을 링크를 통해 일렬로 나열할 수 있는 연결된 구조를 연결 리스트(Linked List)라 부른다. 항목들을 노드(node)라고 하는데,데이터와 함께 링크를 갖는다. 연결된 구조에서 링크의 수를 늘리면 선형 자료구조 뿐 아니라 트리나 그래프와 같이 더 복잡한 구조도 효율적으로표현할 수 있다. 그렇지만 배열 구조에서와 같이 한번에 k번째 항목의 주소를 계산해서 바로 찾아갈 수는 없다. 시작 항목에서부터 링크를 따라 각 항목을하나씩 찾아갈 수 밖에 없다.연결 리스트의 장단점##장점  배열구조와 달리 연결된 구조는 용량이 고정되지 않는다. 즉 필요한 것만 필요할 때 만들어 쓰기 때문에 메모리를 효율적으로 사용한다.또한 컴퓨터에 메모리가 남아 있는 한 계속 자료를 넣을 수 있다.  중간에 자료를 삽입하거나 삭제하는 것이 용이하다. 연결된 구조에서는 링크만 수정하면 되므로 시간 복잡도가 O(1)이다.##단점  연결된 구조에서는 n번째 항목에 접근하는데 O(n)의 시간이 걸린다. 이것은 배열 구조의 O(1)과 비교하면 큰 단점이다.또한 배열에 비해 상대적으로 구현이 어렵고 오류가 발생하기도 쉽다.##연결 리스트의 구조####노드(node)      연결된 구조에서 하나의 항목은 컴퓨터 용어로 노드(node)라고 한다. 배열 구조에서 각 항목들은 데이터만을 갖는 것과 달리노드는 데이터 필드(data field)와 함께 하나 이상의 링크 필드(link field)를 갖는다.        데이터 필드에는 우리가 저장하고 싶은 데이터가 들어간다. 이것은 정수가 도리 수도 있고 복잡한 클래스의 객체나 심지어 다른 리스트도 될 수 있다.링크 필드는 다른 노드를 가리키는, 즉 다른 노드의 주소를 저장하는 변수이다. 이것을 이용해 연결된 다음 노드에 접근 할 수 있다. 배열에 비해 링크를 위한약간의 추가 공간이 필요하지만, 대부분의 경우 데이터가 훨씬 크므로 링크를 위한 공간은 무시할 수 있다.  ####헤드 포인터(head pointer)  연결 리스트에서 첫 번째 노드의 주소를 저장하는 변수를 헤드 포인터(head pointer)라고 한다. 마지막 노드는 더 이상 연결할 노드가 없다.따라서 링크의 값을 None으로 설정하여 이 노드가 마지막임을 표시한다.##연결 리스트의 종류####단순연결리스트(singly linked list)  하나의 방향으로만 연결되어 있는 구조를 갖는다. 따라서 링크는 하나이며, 이 변수는 다음 노드의 주소를 기억하고 있다. 마지막 노드의 링크는아무것도 연결되어 있지 않다는 것을 나타내기 위해 반드시 None 값을 가져야 한다.####원형연결리스트(circular linked list)  단순연결리스트와 동일한 노드 구조를 사용하지만 맨 마지막 노드의 링크 값이 None이 아니라 다시 첫 번째 노드를 가리킨다는 것이 다르다.따라서 노드들을 순서대로 방문할 때 종료조건에 유의해야 한다.####이중연결리스트(doubly linked list)  하나의 노드가 이전 노드와 다음 노드를 모두 알고 있도록 설계되었다. 따라서 두 개의 링크를 갖는데, 하나의 선행 노드(previous node)를 다른 하나는후속 노드(next node)를 가리킨다. 선행 노드를 위한 링크가 있으면 어떤 노드에서 이전 노드를 바로 찾아갈 수 있다는 장점이 있다. 편리한 만큼 이중으로링크를 정확히 유지해야하기 때문에 코드가 복잡해진다.3.2 단순연결리스트 응용 : 연결된 스택단순연결리스트로 구현된 스택을 연결된 스택(linked stack)라고 한다.#####연결된 스택 알고리즘class Node:    def __init__(self, elem, link=None):        self.data = elem        self.link = linkclass LinkedStack:    def __init__(self):        self.top = None    def isEmpty(self):        return self.top == None    def clear(self):        self.top = None    def push(self, item):        n = Node(item, self.top)        self.top = n    def pop(self):        if not self.isEmpty():            n = self.top            self.top = n.link            return n.data    def peek(self):        if not self.isEmpty():            return self.top.data    def size(self):        node = self.top        count = 0        while not node == None:            node = node.link            count += 1        return count    def display(self, msg = 'LinkedStack:'):        print(msg, end='')        node = self.top        while not node == None:            print(node.data, end='')            node = node.link        print()연결된 스택의 삽입과 삭제 연산의 시간 복잡도도 O(1)이다. 그러나 배열 구조에서 파이썬의 리스트가 용량을 증가시켜야 하는 상황이 발생하면 O(n)의 시간이걸릴 수 있다는 점을 감안한다면 연결된 스택이 더 유리하다. size는 배열에서는 O(1)이지만 연결된 스택에서는 O(n)이다. 물론 크기를 위한 변수를 하나 추가하고,삽입과 삭제 연산에서 이 변수를 잘 관리한다면 O(1) 될 수 있다.3.3 단순연결리스트 응용 : 연결된 리스트스택과는 달리 리스트는 항목의 삽입이나 삭제가 시작노드뿐만 아니라 임의의 위치에서도 가능하다.#####연결된 리스트 알고리즘class LinkedList:    def __init__(self):        self.head = None    def isEmpty(self):        return self.head == None    def clear(self):        self.head = None    def size(self):        node = self.head        count = 0        while not node == None:            node = node.link            count += 1        return count    def display(self, msg = 'LinkedStack:'):        print(msg, end='')        node = self.head        while not node == None:            print(node.data, end='-&gt;')            node = node.link        print(\"None\")    def getNode(self, pos):        if pos &lt; 0:            return None        node = self.head        while pos &gt; 0 and node != None:            node = node.link            pos -= 1        return node    def getEntry(self, pos):        node = self.getNode(pos)        if node == None:            return None        else:            return node.data    def replace(self, pos, elem):        node = self.getNode(pos)        if node != None:            node.data = elem    def find(self, data):        node = self.head        while node is not None:            if node.data == data:                return node            node = node.link        return node    def insert(self, pos, elem):        before = self.getNode(pos-1)        if before == None:            self.head = Node(elem, self.head)        else:            node = Node(elem, before.link)            before.link = node    def delete(self, pos):        before = self.getNode(pos-1)        if before == None:            if self.head is not None:                self.head = self.head.link        elif before.link != None:            before.link = before.link.link3.4 원형연결리스트의 응용 : 연결된 큐큐도 연결된 구조로 구현할 수 있는데, 이러한 큐를 연결된 큐(linked queue)라고 한다. 연결된 큐도 크기가 제한되지 않고 필요한 메모리만 사용한다는 장점과,코드가 더 복잡하고 링크 필드 때문에 메모리 공간을 조금 더 사용하는 단점이 있다. 연결된 큐를 구현하는 가장 간단한 방법은 다음과 같이 단순연결리스트를 사용하는 것으로,맨 앞과 뒤에 있는 노드를 front와 rear가 가리키는 구조이다. 물론 삽입은 후단(rear), 삭제는 전단(front)에서 이루어져야 한다.#####원형연결리스트 알고리즘class CircularLinkedQueue:    def __init__(self):        self.tail = None    def isEmpty(self):        return self.tail == None    def clear(self):        self.tail = None    def peek(self):        if not self.isEmpty():            return self.tail.link.data    def enqueue(self, item):        node = Node(item, None)        if self.isEmpty():            node.link = node            self.tail = node        else:            node.link = self.tail.link            self.tail.link = node            self.tail = node    def dequeue(self):        if not self.isEmpty():            data = self.tail.link.data            if self.tail.link == self.tail:                self.tail = None            else:                self.tail.link = self.tail.link.link            return data    def size(self):        if self.isEmpty():            return 0        else:            count = 1            node = self.tail.link            while not node == self.tail:                node = node.link                count += 1            return count    def display(self, msg = 'CircularLinkedQueue'):        print(msg, end='')        if not self.isEmpty():            node = self.tail.link            while not node == self.tail:                print(node.data, end='')                node = node.link            print(node.data, end='')        print()3.5 이중연결리스트의 응용 : 연결된 덱연결된 구조로 구현한 덱을 연결된 덱(linked deque)라고 한다.#####연결된 덱 알고리즘class DNode:    def __init__(self, elem, prev = None, next = None):        self.data = elem        self.prev = prev        self.next = nextclass DoublyLinkedDeque:    def __init__(self):        self.front = None        self.rear = None    def isEmpty(self):        return self.front == None    def clear(self):        self.front = self.rear = None    def size(self):        node = self.front        count = 0        while not node == None:            node = node.next            count += 1        return count    def display(self, msg = 'LinkedStack:'):        print(msg, end='')        node = self.front        while not node == None:            print(node.data, end=' ')            node = node.next        print()    def addFront(self, item):        node = DNode(item, None, self.front)        if(self.isEmpty()):            self.front = self.rear = node        else:            self.front.prev = node            self.front = node    def addRear(self, item):        node = DNode(item, self.rear, None)        if(self.isEmpty()):            self.front = self.rear = node        else:            self.rear.next = node            self.rear = node    def deleteFront(self):        if not self.isEmpty():            data = self.front.data            self.front = self.front.next            if self.front == None:                self.rear = None            else:                self.front.prev = None            return data    def deleteRear(self):        if not self.isEmpty():            data = self.rear.data            self.rear = self.rear.prev            if self.rear == None:                self.front = None            else:                self.rear.next = None            return data",
        "url": "/LinkedList"
    }
    ,
    
    "queue": {
        "title": "Data_Structure - Queue",
            "author": "jang-seonguk",
            "category": "",
            "content": "      큐(Queue)  2.1 큐(Queue)란?큐는 먼저 들어온 데이터가 먼저 나가는 선입선출(First In First Out)의 특성을 갖는 자료구조이다.큐에서 삽입이 일어나는 곳을 후단(rear)이라 하고 삭제가 일어나는 곳을 전단(front)라고 한다.큐의 기능에는  Queue() : 비어 있는 새로운 큐를 만든다.  isEmpty() : 큐가 비어있으면 True를 아니면 False를 반환한다.  enqueue(x) : 항목 x를 큐의 맨 뒤에 추가한다.  dequeue() : 큐의 맨 앞에 있는 항목을 꺼내 반환한다.  peek() : 큐의 맨 위에 있는 항목을 삭제하지 않고 반환한다.  size() : 큐의 모든 항목들의 개수를 반환한다.  clear() : 큐를 공백상태로 만든다.큐는 어디에 사용할까?      컴퓨터에서 데이터를 주고받을 때 각 주변장치들 사이에 존재하는 속도의 차이나 시간차이를 극복하기 위한 임시 기억 장치로 큐가 사용되는데,이것을 버퍼(buffer)라고 한다. 서비스 콜 센터에서도 콜 큐(call queue)를 사용한다. 큐에 많은 요청이 들어 있으면 고객은 기다려야 하고.먼저 신청한 사람은 반드시 먼저 서비스를 받는다.        컴퓨터와 프린터 사이에 인쇄 작업 큐가 존재한다. 프린터는 CPU에 비해 상대적으로 속도가 느리다. 따라서 CPU는 빠른 속도로 인쇄 데이터를 만들어프린터의 인쇄 작업 큐에 보낸 다음 다른 작업으로 넘어간다. 프린터는 일정한 속도로 인쇄 작업 큐에서 순서대로 데이터를 가져와 인쇄한다.        실시간 비디오 스트리밍에서 다운로드 된 데이터가 비디오를 재생하기에 충분하지 않으면 큐에 순서대로 모아두었다가 충분한 양이 되었을 때 비디오를복원하여 재생한다. 이것을 버퍼링(buffering)이라고 한다.        컴퓨터로 현실 세계를 시뮬레이션 하는 분야에서도 큐가 폭넓게 사용된다. 예를 들어 은행에서 대기표를 뽑고 기다리는 고객들, 공항에서 활주로를 이용해이륙하는 비행기들, 인터넷에서 전송되는 데이터 패킷들을 모델링하는데 큐가 이용된다.  2.2 큐의 구현###원형큐 알고리즘-MAX_QSIZE = 10class CircularQueue:    def __init__(self):        self.front = 0        self.rear = 0        self.items = [None] * MAX_QSIZE    def isEmpty(self):        return self.front == self.rear    def isFull(self):        return self.front == (self.rear+1) % MAX_QSIZE    def clear(self):        self.front = self.rear    def enqueue(self, item):        if not self.isFull():            self.rear = (self.rear+1) % MAX_QSIZE            self.items[self.rear] = item    def dequeue(self):        if not self.isEmpty():            self.front = (self.front+1) % MAX_QSIZE            return self.items[self.front]    def peek(self):        if not self.isEmpty():            return self.items[(self.front + 1) % MAX_QSIZE]    def size(self):        return (self.rear - self.front + MAX_QSIZE) % MAX_QSIZE    def display(self):        out = []        if self.front &lt; self.rear:            out = self.items[self.front+1 : self.rear+1]        else:            out = self.items[self.front+1 : MAX_QSIZE] + self.items[0 : self.rear+1]        print(\"[f=%s, r=%d] ==&gt; \"%(self.front, self.rear), out)2.3 큐의 응용 : 너비우선탐색(BFS, Breadth First Search)너비우선탐색은 출발점에서부터 인접한 위치들을 먼저 방문한 다음, 방문한 위치들에 인접한 위치들을 순서대로 찾아가는 방법이다. 이 과정은출구를 찾거나 모든 위치를 방문할 때까지 계속된다. 깊이우선탐색이 하나의 경로를 선택해 끝까지 가보고 막히면 다시 다른 경로를 시도하는 것과 달리,너비우선탐색은 가까운 위치부터 차근차근 찾아가는 전략을 사용한다. 이러한 너비우선탐색을 위해서는 큐를 사용해야 한다.너비우선탐색 알고리즘map = [['1','1','1','1','1','1'],       ['e','0','0','0','0','1'],       ['1','0','1','0','1','1'],       ['1','1','1','0','0','x'],       ['1','1','1','0','1','1'],       ['1','1','1','1','1','1']]MAZE_SIZE = 6def isValidpos(x, y):    if x &lt; 0 or y &lt; 0 or x &gt;= MAZE_SIZE or y &gt;= MAZE_SIZE:        return False    else:        return map[y][x] == '0' or map[y][x] == 'x'def BFS():    que = CircularQueue()    que.enqueue((0, 1))    print(\"BFS : \")    while not que.isEmpty():        here = que.dequeue()        print(here, end='-&gt;')        x,y = here        if (map[y][x] == 'x'):            return True        else:            map[y][x] = '.'            if isValidpos(x, y-1):                que.enqueue((x, y-1))            if isValidpos(x, y+1):                que.enqueue((x, y+1))            if isValidpos(x-1, y):                que.enqueue((x-1, y))            if isValidpos(x+1, y):                que.enqueue((x+1, y))    return False2.4 덱이란?덱(deque)은 double-ended queue의 줄임말로서 큐의 전단(front)과 후단(rear)에서 모두 삽입과 삭제가 가능한 큐를 의미한다.그렇지만 중간에 삽입하거나 삭제하는 것은 허용하지 않는다.  Deque() : 비어 있는 새로운 덱을 만든다.  isEmpty() : 덱이 비어있으면 True를 아니면 False를 반환한다.  addFront(x) : 항목 x를 덱의 맨 앞에 추가한다.  deleteFront() : 맨 앞의 항목을 꺼내서 반환한다.  getFront() : 맨 앞의 항목을 꺼내지 않고 반환한다.  addRear(x) : 항목 x를 덱의 맨 뒤에 추가한다.  deleteRear() : 맨 뒤의 항목을 꺼내서 반환한다.  getRear() : 맨 뒤의 항목을 꺼내지 않고 반환한다.  isFull() : 덱이 가득 차 있으면 True를 아니면 False를 반환한다.  size() : 덱의 모든 항목들의 개수를 반환한다.  clear() : 덱을 공백상태로 만든다.덱 알고리즘class CircularDeque(CircularQueue): #CircularQueue에서 상속    def __init__(self):        super().__init__()    def addRear(self, item):        self.enqueue(item)    def deleteFront(self):        return self.dequeue()    def getFront(self):        return self.peek()    def addFront(self, item):        if not self.isFull():            self.items[self.front] = item            self.front = self.front - 1            if self.front &lt; 0:                self.front = MAX_QSIZE - 1    def deleteRear(self):        if not self.isEmpty():            item = self.items[self.rear]            self.rear = self.rear - 1            if self.rear &lt; 0:                self.rear = MAX_QSIZE - 1            return item    def getRear(self):        return self.items[self.rear]구현된 덱의 시간 복잡도를 생각해 보면,  이름만 바뀌는 연산든(addRear, deleteFront, getFront)은 이미 큐에서 모두 O(1)임을 확인하였다.  getRear는 명백히 O(1)이다.  새로 추가한 삽입연산 addFront와 삭제연산 deleteRear에서도 항목의 이동을 발생하지 않고, 인덱스만 변경하면 된다.따라서 시간 복잡도는 O(1)이다.2.5 우선순위 큐우선순위 큐는 우선순위의 개념을 큐에 도입한 자료구조이다. 보통의 큐는 먼저 들어온 데이터가 먼저 나가는 구조(FIFO)인데 비해,우선순위 큐(priority queue)는 모든 데이터가 우선순위를 가지고 있고, 들어온 순서와 상관없이 우선순위가 높은 데이터가 먼저 출력되는 구조이다.우선순위 큐는 시뮬레이션이나 네트워크 트래픽 제어, 운영 체제에서의 작업 스케줄링, 수치 해석적인 계산 등 다양한 분야에서 활용되고 있다.  PriorityQueue() : 비어 있는 우선순위 큐를 만든다.  isEmpty() : 우선순위 큐가 공백상태인지를 검사한다.  enqueue(e) : 우선순위를 가진 항목 e를 검사한다.  dequeue() : 가장 우선순위가 높은 항목을 꺼내서 반환한다.  peek() : 가장 우선순위가 높은 요소를 삭제하지 않고 반환한다.  size() : 우선순위 큐의 모든 항목들의 개수를 반환한다.  clear() : 우선순위 큐를 공백상태로 만든다.우선순위 큐 알고리즘class PriorityQueue:    def __init__(self):        self.items = []    def isEmpty(self):        return len(self.items) == 0    def size(self):        return len(self.items)    def clear(self):        self.items = []    def enqueue(self, item):        self.items.append(item)    def findMaxIndex(self):        if self.isEmpty():            return None        else:            highest = 0            for i in range(1, self.size()):                if self.items[i] &gt; self.items[highest]:                    highest = i            return highest    def dequeue(self):        highest = self.findMaxIndex()        if highest is not None:            return self.items.pop(highest)    def peek(self):        highest = self.findMaxIndex()        if highest is not None:            return self.items[highest]2.6 우선순위 큐의 응용 : 미로 탐색import math(ox, oy) = (5,4)def dist(x,y):    (dx, dy) = (ox-x, oy-y)    return math.sqrt(dx*dx + dy*dy)def MySmartSearch():    q = PriorityQueue()    q.enqueue((0,1,-dist(0,1)))    print('PQueue')    while not q.isEmpty():        here = q.dequeue()        print(here[0:2], end = '-&gt;')        x,y,_ = here        if (map[y][x] == 'x'):            return True        else:            map[y][x] = '.'        if isValidpos(x, y-1):            q.enqueue((x, y-1, -dist(x,y-1)))        if isValidpos(x, y+1):            q.enqueue((x, y+1, -dist(x,y+1)))        if isValidpos(x-1, y):            q.enqueue((x-1, y, -dist(x-1,y)))        if isValidpos(x+1, y):            q.enqueue((x+1, y, -dist(x+1,y)))        print(\"우선순위큐 : \", q.items)    return False##우선순위 큐의 주요 응용  압축을 위한 허프만 코딩 트리를 만드는 과정에 우선순위 큐를 사용한다. 빈도가 가장 작은 두 노드를 선택하기 위해서이다.  Kruskal의 최소비용 신장트리 알고리즘에서 우선순위 큐를 사용할 수 있다. 최소비용 신장트리에 포함되지 않은 간선들 중에서 가중치가 가장 작은 간선을반복적으로 선택하기 위해서이다.  Dijkstra의 최단거리 알고리즘에서 우선순위 큐를 사용할 수 있다. 최단거리가 찾아지지 않은 장점들 중에서 가장 거리가 가까운 정점을 선택하기 위해서이다.  인공지능의 A* 알고리즘에서 우선순위 큐를 사용할 수 있다. A* 알고리즘은 상태 공간트리(state space tree)를 이용해서 해를 찾는 과정에서 가장 가능성이 높은(promising)경로를 먼저 선택하여 시도해 보기 위해서이다.",
        "url": "/Queue"
    }
    ,
    
    "stack": {
        "title": "Data_Structure - Stack",
            "author": "jang-seonguk",
            "category": "",
            "content": "      스택(Stack)  1.1 스택이란?스택은 후입선출(Last-In First Out: LIFO)의 자료구조이다.스택의 기능에는  Stack() : 비어 있는 새로운 스택을 만든다.  isEmpty() : 스택이 비어있으면 True를 아니면 False를 반환한다.  push(e) : 항목 e를 스택의 맨 위에 추가한다.  pop() : 스택의 맨 위에 있는 항목을 꺼내 반환한다.  peek() : 스택의 맨 위에 있는 항목을 삭제하지 않고 반환한다.  size() : 스택내의 모든 항목들의 개수를 반환한다.  clear() : 스택을 공백상태로 만든다.스택은 특히 자료의 출력순서가 입력의 역순으로 이루어져야 할 경우에 매우 긴요하게 사용된다.문서나 그림, 수식 등의 편집기에서 되돌리기(undo) 기능을 구현할 때 스택이 사용된다. 되돌리기는 지금까지 실행된 명령어 중에서 가장 최근 것 부터 순차적으로 취소해야 하기 때문이다. 웹 브라우저의 “이전 페이지로 이동” 기능도 마찬가지이다. 가장 최근에본 페이지로 이동하기 위해서는 지금까지 본 페이지 정보를 스택에 저장해야 한다.1.2 스택의 구현class Stack :    def __init__(self):        self.top = []    def isEmpty(self): ## 스택이 비어있는지 확인        return len(self.top) == 0    def size(self): ## 스택의 크기        return len(self.top)    def clear(self): ## 스택을 초기화        self.top = []    def push(self, item): ## 스택에 항목을 넣음        self.top.append(item)    def pop(self): ## 스택 상단에 있는 항목 하나를 스택에서 없앤 후 가져옴        if not self.isEmpty():            return self.top.pop(-1)    def peek(self): ## 스택 상단에 있는 항목        if not self.isEmpty():            return self.top[-1]    def __str__(self): ## Stack 객체를 문자열로 변환        return str(self.top)여기서 만약 append() 메소드 대신 insert() 메소드를 사용하게 된다면, 리스트의 0번 위치에 항목을 넣어야 하므로 리스트의 모든 항목들을 한 칸씩 뒤로밀어야 한다. 이 경우 삽입 연산의 시간 복잡도가 O(n)이 되므로 insert() 메소드는 비효율적이다.1.3 스택의 응용 : 괄호 검사수식 표기나 프로그래밍 언어, HTML 문서 등 다양한 분야에서 괄호와 같은 구분 문자(delimiter)들을 사용한다. 이들은 주로 간단한 데이터나 문자열들을 묶어 하나의 그룹으로 만들 때 그룹의 시작과끝을 나타낸다.프로그램이 정상적으로 빌드되고 실행되려면 이들 괄호들이 같은 유형들끼리 쌍을 이루어 잘 사용되어야 하는데, 반드시 다음 조건을 맞추어 구성되어야 한다.  조건 1 : 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.  조건 2 : 같은 타입의 괄호에서 왼쪽 괄호가 오른쪽 괄호보다 먼저 나와야 한다.  조건 3 : 서로 다른 타입의 괄호 쌍이 서로를 교차하면 안된다.괄호검사 알고리즘def checkBrackets(statement):    stack = Stack()    for ch in statement:        if ch in ('{', '[', '('):            stack.push(ch)        elif ch in ('}', ']', ')'):            if stack.isEmpty():                return False            else:                left = stack.pop()                if (ch == \"}\" and left != \"{\" or                    ch == \"]\" and left != \"[\" or                    ch == \")\" and left != \"(\"):                    return False    return stack.isEmpty()1.4 스택의 응용 : 수식의 계산기본적으로 수식은 연산자와 피연산자를 이용해 표현하는데, 이들의 상대적인 위치에 따라 다음과 세 가지 표기법으로 구분된다.  전위(prefix) : 연산자 피연산자1 피연산자2          + A B      + 5 * A B        중위(infix) : 피연산자1 연산자 피연산자2          A + B      5 + A * B        후위(postfix) : 피연산자1 피연산자2 연산자          A B +      5 A B * +      우리는 중위표기법에 익숙하지만 컴퓨터는 후위표기법을 선호한다. 후위표기법은 컴퓨터 입장에서 여러 가지 장점이 있는데,  괄호를 사용하지 않아도 계산 순서를 알 수 있다.  연산자의 우선순위를 생각할 필요가 없다. 식 자체에 우선순위가 이미 포함되어 있기 때문이다.  수식을 읽으면서 바로 계산할 수 있다. 중위 표현식은 괄호와 연산자의 우선순위 때문에 수식을 끝까지 읽은 다음에야 계산이 가능하다.이러한 이유로 사용자가 입력한 중위표기를 후위표기로 변환한 다음 컴퓨터가 그 식을 계산해야 한다.후위표기 수식 계산 알고리즘def evealPostfix(expr):    s = Stack()    for token in expr:        if token in expr:            if token in \"+-*/\":                val2 = s.pop()                val1 = s.pop()                if (token == '+'):                    s.push(val1 + val2)                elif (token == '-'):                    s.push(val1 - val2)                elif (token == '*'):                    s.push(val1 * val2)                elif (token == '/'):                    s.push(val1 / val2)            else:                s.push(float(token))    return s.pop()스택을 이용한 중위표기 수식으 후위표기 변환  입력된 중위표기 수식을 순서대로 하나씩 스캔한다.  피연산자를 만나면 바로 (후위표기 수식으로) 출력한다.  연산자는 스택에 저장한다.  현재 연산자보다 우선순위가 높은 연산자는 모두 먼저 출력한 후 현재 연산자를 스택에 넣는다.  우선순위가 같은 경우도 먼저 출력해야 한다.  입력 수식이 끝나면 스택의 남은 연산자들을 모두 pop() 해서 후위표기 수식으로 출력한다.  왼쪽 괄호는 무조건 스택에 삽입한다. 왼쪽 괄호가 일단 스택에 삽입되면 우리는 왼쪽 괄호를 제일 우선순위가 낮은 연산자로 취급한다.  오른쪽 괄호를 만나면 왼쪽 괄호가 삭제될 때까지 왼쪽 괄호위에 쌓여있는 모든 연산자들을 출력한다.중위표기식의 후위 변환 알고리즘def precedence(op):    if op == '(' or op == ')':        return 0    elif op == '+' or op == '-':        return 1    elif op == '*' or op == '/':        return 2    else:        return -1def Infix2Postfix(expr):    s = Stack()    output = []    for term in expr:        if term in '(':            s.push('(')        elif term in ')':            while not s.isEmpty():                op = s.pop()                if op == '(':                    break                else:                    output.append(op)        elif term in \"+-*/\":            while not s.isEmpty():                op = s.peek()                if (precedence(term) &lt;= precedence(op)):                    output.append(op)                    s.pop()                else:                    break            s.push(term)        else:            output.append(term)    while not s.isEmpty():        output.append(s.pop())    return output1.5 스택의 응용 : 미로 탐색가장 간단한 탐색 방법은 시행착오를 이용하는 것으로 하나의 경로를 선택하여 시도해 보고 막히면 다시 다른 경로를 시도하는 것이다. 이때 현재의 경로가 막혔을 때다시 선택할 수 있는 다른 경로들을 어딘가에 저장해야 한다. 즉 가던 길이 막히면 가장 최근에 있었던 갈림길로 되돌아가서 다른 곳을 찾는것이다. 이러한 방법을깊이 우선 탐색(DFS, Depth First Search)이라고 한다.탐색 알고리즘  Step1 : 시작위치를 스택에 넣는다. 현재 스택에는 시작위치만 들어 있다.  Step2 : 스택이 공백이 아니면 하나의 위치를 꺼낸다. 이것이 현재 위치이다. 현재 위치에 “방문했음” 표시를 한다.만약 스택이 공백이라면 이 미로에는 출구가 없는 것이므로 종료한다.  Step3 : 만약 현재위치가 출구이면 탐색은 성공으로 끝난다.  Step4 : 그렇지 않으면 이웃(상하좌우)방들을 살펴본다. 만약 이웃 방들이 아직 방문되지 않았고 갈 수 있는 방이라면그 방의 위치를 모두 스택에 삽입한다. 다시 Step2로 돌아간다.스택을 이용한 탐색 알고리즘map = [['1','1','1','1','1','1'],       ['e','0','0','0','0','1'],       ['1','0','1','0','1','1'],       ['1','1','1','0','0','x'],       ['1','1','1','0','1','1'],       ['1','1','1','1','1','1']]MAZE_SIZE = 6def isValidpos(x, y):    if x &lt; 0 or y &lt; 0 or x &gt;= MAZE_SIZE or y &gt;= MAZE_SIZE:        return False    else:        return map[y][x] == '0' or map[y][x] == 'x'def DFS():    stack = Stack()    stack.push((0,1))    print('DFS: ')    while not stack.isEmpty():        here = stack.pop()        print(here, end = '-&gt;')        (x,y) = here        if (map[y][x] == 'x'):            return True        else:            map[y][x] = '.'            if isValidpos(x, y-1):                stack.push((x, y-1))            if isValidpos(x, y+1):                stack.push((x, y+1))            if isValidpos(x-1, y):                stack.push((x-1, y))            if isValidpos(x+1, y):                stack.push((x+1, y))        print(' 현재 스택 : ', stack)    return False",
        "url": "/stack"
    }
    ,
    
    "python-control-statement": {
        "title": "Python 강좌(2) - Python 제어문",
            "author": "jang-seonguk",
            "category": "",
            "content": "Python 강좌는 여러 절로 구성되어 있습니다.     Python 강좌(1) - Python 기본    Python 강좌(2) - Python 제어문이 글은 python의 제어문에 관한 내용입니다.class Stack :    def __init__(self):        self.top = []    def isEmpty(self):        return len(self.top) == 0    def size(self):        return len(self.top)    def clear(self):        self.top = []    def push(self, item):        self.top.append(item)    def pop(self):        if not self.isEmpty():            return self.top.pop(-1)    def peek(self):        if not self.isEmpty():            return self.top[-1]    def __str__(self):        return str(self.top)def checkBrackets(statement):    stack = Stack()    for ch in statement:        if ch in (&#39;{&#39;, &#39;[&#39;, &#39;(&#39;):            stack.push(ch)        elif ch in (&#39;}&#39;, &#39;]&#39;, &#39;)&#39;):            if stack.isEmpty():                return False            else:                left = stack.pop()                if (ch == &quot;}&quot; and left != &quot;{&quot; or                    ch == &quot;]&quot; and left != &quot;[&quot; or                    ch == &quot;)&quot; and left != &quot;(&quot;):                    return False    return stack.isEmpty()def evealPostfix(expr):    s = Stack()    for token in expr:        if token in expr:            if token in &quot;+-*/&quot;:                val2 = s.pop()                val1 = s.pop()                if (token == &#39;+&#39;):                    s.push(val1 + val2)                elif (token == &#39;-&#39;):                    s.push(val1 - val2)                elif (token == &#39;*&#39;):                    s.push(val1 * val2)                elif (token == &#39;/&#39;):                    s.push(val1 / val2)            else:                s.push(float(token))    return s.pop()def precedence(op):    if op == &#39;(&#39; or op == &#39;)&#39;:        return 0    elif op == &#39;+&#39; or op == &#39;-&#39;:        return 1    elif op == &#39;*&#39; or op == &#39;/&#39;:        return 2    else:        return -1def Infix2Postfix(expr):    s = Stack()    output = []    for term in expr:        if term in &#39;(&#39;:            s.push(&#39;(&#39;)        elif term in &#39;)&#39;:            while not s.isEmpty():                op = s.pop()                if op == &#39;(&#39;:                    break                else:                    output.append(op)        elif term in &quot;+-*/&quot;:            while not s.isEmpty():                op = s.peek()                if (precedence(term) &lt;= precedence(op)):                    output.append(op)                    s.pop()                else:                    break            s.push(term)        else:            output.append(term)    while not s.isEmpty():        output.append(s.pop())    return outputmap = [[&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;],       [&#39;e&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;1&#39;],       [&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;1&#39;],       [&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;x&#39;],       [&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;1&#39;],       [&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;]]MAZE_SIZE = 6def isValidpos(x, y):    if x &lt; 0 or y &lt; 0 or x &gt;= MAZE_SIZE or y &gt;= MAZE_SIZE:        return False    else:        return map[y][x] == &#39;0&#39; or map[y][x] == &#39;x&#39;def DFS():    stack = Stack()    stack.push((0,1))    print(&#39;DFS: &#39;)    while not stack.isEmpty():        here = stack.pop()        print(here, end = &#39;-&gt;&#39;)        (x,y) = here        if (map[y][x] == &#39;x&#39;):            return True        else:            map[y][x] = &#39;.&#39;            if isValidpos(x, y-1):                stack.push((x, y-1))            if isValidpos(x, y+1):                stack.push((x, y+1))            if isValidpos(x-1, y):                stack.push((x-1, y))            if isValidpos(x+1, y):                stack.push((x+1, y))        print(&#39; 현재 스택 : &#39;, stack)    return False",
        "url": "/python-control-statement"
    }
    ,
    
    "python-basic": {
        "title": "Python 강좌(1) - Python 기본",
            "author": "jang-seonguk",
            "category": "",
            "content": "Python 강좌는 여러 절로 구성되어 있습니다.     Python 강좌(1) - Python 기본    Python 강좌(2) - Python 제어문이 글은 python baisc 입니다.!!gggggfunction syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}",
        "url": "/python-basic"
    }
    ,
    
    "gettysburg-address": {
        "title": "Gettysburg Address",
            "author": "abraham",
            "category": "",
            "content": "Fourscore and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.But, in a larger sense, we can not dedicate-we can not consecrate-we can not hallow-this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us-that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion-that we here highly resolve that these dead shall not have died in vain-that this nation, under God, shall have a new birth of freedom-and that government of the people, by the people, for the people shall not perish from the earth.",
        "url": "/gettysburg-address"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://jang-seonguk.github.io/">IT Technical Training</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search IT Technical Training</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
